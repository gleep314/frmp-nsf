%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
\label{sec:frp_background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we review the essential characteristics of functional programming that we believe make it an excellent fit for modeling chemical reaction networks.
We also introduce the fundamentals of functional reactive programming which form the basis of our proposed language design.

\subsection{Characteristics of Functional Programming}

Functional programming encompasses a wide range of practices centered on organizing programs through the composition of functions.
In this proposal, we focus exclusively on \emph{pure, strong-typed functional programming} as best exemplified by the Haskell programming language.
By \emph{pure}, we mean that functions exhibit no (uncontrolled) side-effects such as variable mutation, exceptions, or input-output.
Because of this, functions in such a language enjoy \emph{referential transparency}, \ie, they behave like mathematical functions, allowing us to compose them while preserving their respective properties.
A \emph{strong, static type system} acts as a lightweight verification tool, allowing a compiler to check properties of the input program.
These properties are simple when the type system itself is simple, but can grow in increasingly complexity by scaling up the complexity of the type system.

In addition to these properties, Huges~\cite{huges:1990} outlines a pair of additional \emph{positive properties} of languages like Haskell that allow for the creation of highly modular, composable code.
\emph{Higher-order functions} and \emph{parametric polymorphism} allow us to write highly-generic, reusable libraries that can serve many purposes.
We can push their features to their limit and author complete \emph{domain-specific languages} embedded within a host language that enjoy the high-level features of the host but allow for direct manipulate of objects in the target domain.
\emph{Lazy evaluation}, where code is not executed until it is absolutely required by the computation, allows us to efficiently and elegantly process \emph{streams} of data in a uniform manner.

Finally, we acknowledged that there is a significant trade-off between language safety guarantees and complexity when considering a pure, strongly-typed functional programming languages.
However, in his work, PI Osera and his collaborators have found that the additional information provided by a static type system in this situation can be utilized by \emph{program synthesis techniques}~\cite{osera:thesis:2015} to provide users with rich editing support.
These tools can help automate much of the tedium and difficult in navigating the rich types of these languages.

\subsection{Functional Reactive Programming}

Many systems can be modeled as collections of components interacting with their environment.
For example:
\begin{itemize}[itemsep=0pt]
  \item The components of a graphical user interface (GUI) must respond to actions from the user.
  \item A robot must respond to outside stimuli it perceives through its sensors.
  \item Objects in an interactive simulation (such as a game) must respond to actions generated by other objects.
  \item A circuit must respond to changes in voltage in its inputs.
  \item Concentrations of molecules respond to the presence of other molecues in a beaker according to a set of reactions.
\end{itemize}
In traditional systems, this sort of behavior is modeled through explicit management of events, notifications, and behaviors associated with each event.
However, the low-level details of how components interact and how the underlying system manages those interactions obscure what is essential about the computation: how a particular component \emph{reacts} to these events.

For example, consider the case of graphical user interfaces where functional reactive programming has found most of its success.
Imagine writing code that allows a user to click on a widget in the interface.
We aren't concerned about how the widget in the GUI is notified that it has been clicked.
Instead, we want to focus its behavior when it has been clicked, \eg, updating an internal counter upon a click.
This problem becomes compounded when considering richer forms of reactions such as \emph{chains of reactions} where, for example, a textbox should react to the updating of the internal counter by updating its own textual display with the appropriate amount.

For example, the following Haskell code snippet using the \texttt{Wx} library updates a label based on the position of the mouse on the screen.
\begin{haskellcode}
window :: IO ()
window = do
  f <- frame [text := "Example Mouse Tracker"]
  b <- button f [text := "", on command := close f]
  set f [ layout := margin 10 (column 10 [floatCentre (widget b)] )
        , on motion := (\p -> set b [text := (show p)] )
        ]
\end{haskellcode}
\texttt{Wx} is a traditional GUI library with an event-based model for handling messages between components, so we must (a) explicitly manage the plumbing of notifications between the label and mouse events and (b) update the label in a stateful manner.
The second point is particularly problematic because we lose the benefits of compositional reasoning that pure, functional programming provides by introducing mutation.
In short, rather than updating the text---which is specifying ``how'' a computation ought to be performed---we want to be able to state directly ``what'' the text of the button ought to be.

\emph{Functional reactive programming} (FRP)~\cite{elliott1997, czaplicki2013, finkbeiner2019, jeffrey2012} addresses these concerns directly.
\begin{enumerate}[itemsep=0pt]
  \item We model notifications as \emph{lazy streams of events} that an object processes over time.
  \item We model objects as \emph{signals}, \emph{time-varying values}.
\end{enumerate}
Thus, when we define an object, we define it as a time-varying function reacting to streams of events.
This allows us to retain a declarative, equational style in our code.

To demonstrate these concepts, let's consider a FRP-based implementation of the mouse tracker code above.
In a FRP system, the position of the mouse is a basic signal that we can then transform using various combinators into something more useful for our purposes, \eg, updating the label of our button.
The following example utilizes the \texttt{reactive-banana} library source code, a Haskell library for FRP~\cite{reactive-banana}, that contains bindings to \texttt{Wx}.
The intent of this example is to not present how to program in \texttt{reactive-banana}, so we elide most of the details of how the various combinators operator.
Instead, we wish to empahsize the declarative nature of the code and the way that the signals are defined in terms of each other.

First we begin by defining the signal for mouse positions, \hask{bmouse}.
\begin{haskellcode}
 -- NOTE: Signals are called Behaviors in reactive-banana
(bmouse :: Behavior Vector) <-
  fmap fromPoint <$> stepper (point 0 0)
    (filterJust $ justMotion <$> emouse)
\end{haskellcode}
\hask{bmouse} has type \hask{Behavior Vector}, a continuous signal of a vector (a coordinate pair) which is generated by the time-varying position of the mouse cursor.

\todo{Switch this example code to GUI code for updating a button's label.}
Next, we can reflect this signal onto another object by referencing \hask{bmouse} in code.
For example, we can now define the velocity of a sprite on screen in relation to the mouse cursor:
\begin{haskellcode}
bvelocity :: Behavior Vector
  bvelocity =
    (\pos mouse -> speedup $ mouse `vecSub` pos `vecSub` vec 0 45)
    <$> bposition <*> bmouse
  where
    speedup v = v `vecScale` (vecLengthDouble v / 20)
\end{haskellcode}
This code calculates the velocity of the sprite as the difference of the sprite's position and the mouse's position with a constant \hask{speedup} factor.
\end{haskellcode}

Finally, with \hask{bvelocity} in hand, we can define the sprite's position \hask{bposition} in terms of the velocity signal we just defined:
\begin{haskellcode}
(bposition :: Behavior Vector)
  <- accumB (vec 0 0) $
      (\v pos -> clipToFrame $ (v `vecScale` dt) `vecAdd` pos)
      <$> bvelocity <@ etick
\end{haskellcode}

In summary, note the declarative power of the functional reactive style!
Through the various combinators, we can compose together signals starting with a signal of mouse positions and ending with a signal corresponding to the position of a sprite on the screen.
FRP systems offer a rich set of abstractions for specifying reactive systems of significant depth and complexity.
