%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functional Reactive Programming}
\label{sec:frp_background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo{We should consider rewriting this FRP introduction to focus on Haskell, Yampa, and the Arrow typeclass to help lay the groundwork for the following sections.}
% Many systems can be modeled as collections of components interacting with their environment.
% For example:
% \begin{itemize}[itemsep=0pt]
%   \item The components of a graphical user interface (GUI) must respond to actions from the user.
%   \item A robot must respond to outside stimuli it perceives through its sensors.
%   \item Objects in an interactive simulation (such as a game) must respond to actions generated by other objects.
%   \item A circuit must respond to changes in voltage in its inputs.
% \end{itemize}
% In traditional systems, this sort of behavior is modeled through explicit management of events, notifications, and behaviors associated with each event.
% However, the low-level details of how components interact and how the underlying system manages those interactions obscure what is essential about the computation: how a particular component \emph{reacts} to these events.
% For example, we aren't concerned about how a widget in a GUI is notified that it has been clicked.
% Instead, we want to focus its behavior when it has been clicked, \eg, updating an internal counter upon a click.
% This problem becomes compounded when considering richer forms of reactions such as chains of reactions where, for example, a textbox should react to the updating of the internal counter by updating its own textual display with the appropriate amount.

% \emph{Reactive programming} is a declarative programming paradigm that better captures this phenomenon.
% In reactive programming, we model these events as streams of data and components directly define how they react to these streams.
% This results in an \emph{asynchronous dataflow language} where we are concerned with capturing how the streams of data generated by the environment are transformed by the components of the system.
% For example, in RxJS, an extension library to Javascript that adds reactive features, we can create a stream of mouse movement events for a button and then define how the system reacts to updates about that event:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}[language=Javascript]
% var clickStream = Rx.Observable.fromEvent(document, 'mousemove');
% clickStream.subscribe(e => label.innerText = e)
% \end{lstlisting}\end{tabular}\end{center}
% Now whenever the user moves the mouse, the callback passed to \verb+subscribe+ fires, updating the \verb+label+'s text so that it reflects the position of the mouse.
% More generally, reactive systems like RxJS allow for the declaration of complex dataflow systems that are defined purely in terms of reactive behavior how components are notified of relevant events.

% While reactive programming solves the problem of hiding the details of how components are notified of events, the above example is unsatisfactory in the sense that the text of the label must manually be updated with respect to a new event that appears on the stream.
% Rather than updating the text---which is specifying ``how'' a computation ought to be performed---we want to be able to state directly ``what'' the text ought to be.
% \emph{Functional reactive programming} (FRP)~\cite{elliott1997, czaplicki2013, finkbeiner2019, jeffrey2012} builds enables this by introducing the notion of a \emph{signal}, a \emph{time-varying value} to our reactive model.
% Intuitively, when we work with a signal, we think of it as a continuously-updated value.
% Thus, when we define how a component reacts to a signal, we can write the reactive code in terms in a declarative, equational manner.

% To demonstrate this, let's consider how we might manipulate a signal representing the continuous position of the mouse on the screen.
% In a FRP system, the position of the mouse is a basic signal that we can then transform using various combinators into something more useful for our purposes, \eg, controlling a sprite on the screen.
% The following example is drawn from the \texttt{reactive-banana} library source code, a Haskell library for FRP~\cite{reactive-banana}.
% The intent of this example is to not present how to program in \texttt{reactive-banana}, so we elide most of the details of how the various combinators operator.
% Instead, pay attention to the declarative nature of the code and the way that the signals are defined in terms of each other.

% First we begin by defining the signal for mouse positions, \lstinline!bmouse!.
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
% -- Signals are called Behaviors in reactive-banana
% (bmouse :: Behavior Vector) <-
%     fmap fromPoint <$> stepper (point 0 0)
%         (filterJust $ justMotion <$> emouse)
% \end{lstlisting}\end{tabular}\end{center}
% \lstinline!bmouse! has type \lstinline!Behavior Vector!, a continuous signal of a vector (a coordinate pair) which is generated by the time-varying position of the mouse cursor.

% Next, we can reflect this signal onto another object by referencing \lstinline!bmouse! in code.
% For example, we can now define the velocity of a sprite on screen in relation to the mouse cursor:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
%   bvelocity :: Behavior Vector
%   bvelocity =
%     (\pos mouse -> speedup $ mouse `vecSub` pos `vecSub` vec 0 45)
%     <$> bposition <*> bmouse
%     where
%     speedup v = v `vecScale` (vecLengthDouble v / 20)
% \end{lstlisting}\end{tabular}\end{center}
% This code calculates the velocity of the sprite as the difference of the sprite's position and the mouse's position with a constant \lstinline!speedup! factor.

% Finally, with \lstinline!bvelocity! in hand, we can define the sprite's position \lstinline!bposition! in terms of the velocity signal we just defined:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
% (bposition :: Behavior Vector)
%   <- accumB (vec 0 0) $
%       (\v pos -> clipToFrame $ (v `vecScale` dt) `vecAdd` pos)
%       <$> bvelocity <@ etick
% \end{lstlisting}\end{tabular}\end{center}

% In summary, note the declarative power of the functional reactive style!
% Through the various combinators, we can compose together signals starting with a signal of mouse positions and ending with a signal corresponding to the position of a sprite on the screen.
% FRP systems offer a rich set of abstractions for specifying reactive systems of significant depth and complexity.

