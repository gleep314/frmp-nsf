%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
\label{sec:frp_background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we review the essential characteristics of functional programming that we believe make it an excellent fit for modeling chemical reaction networks.
We also introduce the fundamentals of functional reactive programming which form the basis of our proposed language design.

\subsection{Characteristics of Functional Programming}

Functional programming encompasses a wide range of practices centered on organizing programs through the composition of functions.
In this proposal, we focus exclusively on \emph{pure, strong-typed functional programming} as best exemplified by the Haskell programming language.
By \emph{pure}, we mean that functions exhibit no (uncontrolled) side-effects such as variable mutation, exceptions, or input-output.
Because of this, functions in such a language enjoy \emph{referential transparency}, \ie, they behave like mathematical functions, allowing us to compose them while preserving their respective properties.
A \emph{Strong, static type system} acts as a lightweight verification tool, allowing a compiler to check properties of the input program.
These properties are simple when the type system itself is simple, but can grow in increasingly complexity by scaling up the complexity of the type system.

In addition to these properties, Huges~\cite{huges:1990} outlines a pair of additional \emph{positive properties} of languages like Haskell that allow for the creation of highly modular, composable code.
\emph{Higher-order functions} and \emph{parametric polymorphism} allow us to write highly-generic, reusable libraries that can serve many purposes.
We can push their features to their limit and author complete \emph{domain-specific languages} embedded within a host language that enjoy the high-level features of the host but allow for direct manipulate of objects in the target domain.
\emph{Lazy evaluation}, where code is not executed until it is absolutely required by the computation, allows us to efficiently and elegantly process \emph{streams} of data in a uniform manner.

Finally, we acknowledged that there is a significant trade-off between language safety guarantees and complexity when considering a pure, strongly-typed functional programming languages.
However, in his work, PI Osera and his collaborators have found that the additional information provided by a static type system in this situation can be utilized by \emph{program synthesis techniques}~\cite{osera:thesis:2015} to provide users with rich editing support.
These tools can help automate much of the tedium and difficult in navigating the rich types of these languages.

\subsection{Functional Reactive Programming}

Many systems can be modeled as collections of components interacting with their environment.
For example:
\begin{itemize}[itemsep=0pt]
  \item The components of a graphical user interface (GUI) must respond to actions from the user.
  \item A robot must respond to outside stimuli it perceives through its sensors.
  \item Objects in an interactive simulation (such as a game) must respond to actions generated by other objects.
  \item A circuit must respond to changes in voltage in its inputs.
\end{itemize}
In traditional systems, this sort of behavior is modeled through explicit management of events, notifications, and behaviors associated with each event.
However, the low-level details of how components interact and how the underlying system manages those interactions obscure what is essential about the computation: how a particular component \emph{reacts} to these events.
For example, we aren't concerned about how a widget in a GUI is notified that it has been clicked.
Instead, we want to focus its behavior when it has been clicked, \eg, updating an internal counter upon a click.
This problem becomes compounded when considering richer forms of reactions such as chains of reactions where, for example, a textbox should react to the updating of the internal counter by updating its own textual display with the appropriate amount.

\emph{Reactive programming} is a declarative programming paradigm that better captures this phenomenon.
In reactive programming, we model these events as streams of data and components directly define how they react to these streams.
This results in an \emph{asynchronous dataflow language} where we are concerned with capturing how the streams of data generated by the environment are transformed by the components of the system.
For example, in RxJS, an extension library to Javascript that adds reactive features, we can create a stream of mouse movement events for a button and then define how the system reacts to updates about that event:
\begin{javascriptcode}
var clickStream = Rx.Observable.fromEvent(document, 'mousemove');
clickStream.subscribe(e => label.innerText = e)
\end{javascriptcode}
Now whenever the user moves the mouse, the callback passed to \verb+subscribe+ fires, updating the \verb+label+'s text so that it reflects the position of the mouse.
More generally, reactive systems like RxJS allow for the declaration of complex dataflow systems that are defined purely in terms of reactive behavior how components are notified of relevant events.

While reactive programming solves the problem of hiding the details of how components are notified of events, the above example is unsatisfactory in the sense that the text of the label must manually be updated with respect to a new event that appears on the stream.
Rather than updating the text---which is specifying ``how'' a computation ought to be performed---we want to be able to state directly ``what'' the text ought to be.
\emph{Functional reactive programming} (FRP)~\cite{elliott1997, czaplicki2013, finkbeiner2019, jeffrey2012} builds enables this by introducing the notion of a \emph{signal}, a \emph{time-varying value} to our reactive model.
Intuitively, when we work with a signal, we think of it as a continuously-updated value.
Thus, when we define how a component reacts to a signal, we can write the reactive code in terms in a declarative, equational manner.

To demonstrate this, let's consider how we might manipulate a signal representing the continuous position of the mouse on the screen.
\begin{itemize}
  \item Choose a non-gui example perhaps closer to CRNs.
  \item Mock up the example for the reactive discussion above as well as here.
  \item Use Yampa in the example to introduce syntax.
\end{itemize}

In summary, note the declarative power of the functional reactive style!
Through the various combinators, we can compose together signals starting with a signal of mouse positions and ending with a signal corresponding to the position of a sprite on the screen.
FRP systems offer a rich set of abstractions for specifying reactive systems of significant depth and complexity.

\todo{We should consider rewriting this FRP introduction to focus on Haskell, Yampa, and the Arrow typeclass to help lay the groundwork for the following sections.}
% Many systems can be modeled as collections of components interacting with their environment.
% For example:
% \begin{itemize}[itemsep=0pt]
%   \item The components of a graphical user interface (GUI) must respond to actions from the user.
%   \item A robot must respond to outside stimuli it perceives through its sensors.
%   \item Objects in an interactive simulation (such as a game) must respond to actions generated by other objects.
%   \item A circuit must respond to changes in voltage in its inputs.
% \end{itemize}
% In traditional systems, this sort of behavior is modeled through explicit management of events, notifications, and behaviors associated with each event.
% However, the low-level details of how components interact and how the underlying system manages those interactions obscure what is essential about the computation: how a particular component \emph{reacts} to these events.
% For example, we aren't concerned about how a widget in a GUI is notified that it has been clicked.
% Instead, we want to focus its behavior when it has been clicked, \eg, updating an internal counter upon a click.
% This problem becomes compounded when considering richer forms of reactions such as chains of reactions where, for example, a textbox should react to the updating of the internal counter by updating its own textual display with the appropriate amount.

% \emph{Reactive programming} is a declarative programming paradigm that better captures this phenomenon.
% In reactive programming, we model these events as streams of data and components directly define how they react to these streams.
% This results in an \emph{asynchronous dataflow language} where we are concerned with capturing how the streams of data generated by the environment are transformed by the components of the system.
% For example, in RxJS, an extension library to Javascript that adds reactive features, we can create a stream of mouse movement events for a button and then define how the system reacts to updates about that event:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}[language=Javascript]
% var clickStream = Rx.Observable.fromEvent(document, 'mousemove');
% clickStream.subscribe(e => label.innerText = e)
% \end{lstlisting}\end{tabular}\end{center}
% Now whenever the user moves the mouse, the callback passed to \verb+subscribe+ fires, updating the \verb+label+'s text so that it reflects the position of the mouse.
% More generally, reactive systems like RxJS allow for the declaration of complex dataflow systems that are defined purely in terms of reactive behavior how components are notified of relevant events.

% While reactive programming solves the problem of hiding the details of how components are notified of events, the above example is unsatisfactory in the sense that the text of the label must manually be updated with respect to a new event that appears on the stream.
% Rather than updating the text---which is specifying ``how'' a computation ought to be performed---we want to be able to state directly ``what'' the text ought to be.
% \emph{Functional reactive programming} (FRP)~\cite{elliott1997, czaplicki2013, finkbeiner2019, jeffrey2012} builds enables this by introducing the notion of a \emph{signal}, a \emph{time-varying value} to our reactive model.
% Intuitively, when we work with a signal, we think of it as a continuously-updated value.
% Thus, when we define how a component reacts to a signal, we can write the reactive code in terms in a declarative, equational manner.

% To demonstrate this, let's consider how we might manipulate a signal representing the continuous position of the mouse on the screen.
% In a FRP system, the position of the mouse is a basic signal that we can then transform using various combinators into something more useful for our purposes, \eg, controlling a sprite on the screen.
% The following example is drawn from the \texttt{reactive-banana} library source code, a Haskell library for FRP~\cite{reactive-banana}.
% The intent of this example is to not present how to program in \texttt{reactive-banana}, so we elide most of the details of how the various combinators operator.
% Instead, pay attention to the declarative nature of the code and the way that the signals are defined in terms of each other.

% First we begin by defining the signal for mouse positions, \lstinline!bmouse!.
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
% -- Signals are called Behaviors in reactive-banana
% (bmouse :: Behavior Vector) <-
%     fmap fromPoint <$> stepper (point 0 0)
%         (filterJust $ justMotion <$> emouse)
% \end{lstlisting}\end{tabular}\end{center}
% \lstinline!bmouse! has type \lstinline!Behavior Vector!, a continuous signal of a vector (a coordinate pair) which is generated by the time-varying position of the mouse cursor.

% Next, we can reflect this signal onto another object by referencing \lstinline!bmouse! in code.
% For example, we can now define the velocity of a sprite on screen in relation to the mouse cursor:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
%   bvelocity :: Behavior Vector
%   bvelocity =
%     (\pos mouse -> speedup $ mouse `vecSub` pos `vecSub` vec 0 45)
%     <$> bposition <*> bmouse
%     where
%     speedup v = v `vecScale` (vecLengthDouble v / 20)
% \end{lstlisting}\end{tabular}\end{center}
% This code calculates the velocity of the sprite as the difference of the sprite's position and the mouse's position with a constant \lstinline!speedup! factor.

% Finally, with \lstinline!bvelocity! in hand, we can define the sprite's position \lstinline!bposition! in terms of the velocity signal we just defined:
% \begin{center}\begin{tabular}{c}\begin{lstlisting}
% (bposition :: Behavior Vector)
%   <- accumB (vec 0 0) $
%       (\v pos -> clipToFrame $ (v `vecScale` dt) `vecAdd` pos)
%       <$> bvelocity <@ etick
% \end{lstlisting}\end{tabular}\end{center}

% In summary, note the declarative power of the functional reactive style!
% Through the various combinators, we can compose together signals starting with a signal of mouse positions and ending with a signal corresponding to the position of a sprite on the screen.
% FRP systems offer a rich set of abstractions for specifying reactive systems of significant depth and complexity.

