%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FRP and Deterministic CRNs}
\label{sec:frp_dcrns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One of the most prominent semantics for chemical reaction networks is \emph{deterministic mass action kinetics}, where the number of molecules of each species is modeled as a continuously-varying concentration~\cite{oErdTot89,oEpsPoj98,oGuna03,oLent15}.
These concentrations evolve according to a system of ordinary differential equations (ODEs), derived from the \emph{law of mass action} and the reactions within the network.
Deterministic CRNs are inherently \emph{analog} and are closely related to Shannon's general purpose analog computer (GPAC)~\cite{jShan41,jGraCos03,jGrac04,cBoGrPo16,cFLBP17,rtcrn2}.
For example, the CRN \( X_1 + X_2 \goesto{} Y \) from Figure~\ref{fig:min_max_example} (a) computes the \emph{minimum} of the initial concentrations of \( X_1 \) and \( X_2 \).
The law of mass action requires that the rate of this reaction at time \( t \) is proportional to the product of the concentration of its reactants at time \( t \), denoted by \( x_1(t) \) and \( x_2(t) \).
Since this reaction has a positive net effect on \( Y \) and a negative net effect on \( X_1 \) and \( X_2 \), the ODEs for the three species are:
\[
    \frac{dx_1}{dt} = -x_1(t)x_2(t), \qquad
    \frac{dx_2}{dt} = -x_1(t)x_2(t), \qquad
    \frac{dy}{dt}   =  x_1(t)x_2(t).
\]

Commonly, deterministic CRNs and GPACs receive their input via an \emph{initial state} (at time zero), process it, and present their output at some future time \( t \).
For the CRN computing the minimum function above, the concentration of its output \( Y \) converges to the appropriate value as \( t \) approaches infinity.
However, deterministic CRNs and GPACs can also be regarded as \emph{signal processors} that receive a continuously varying input signal, while producing a continuous output signal in real time.
This characterization of computation with deterministic CRNs is used in~\cite{jKlLaLu20} to show that any nondeterministic finite automaton can be simulated in real time by a deterministic CRN.
These CRNs receive their input strings as a sequence of \emph{pulses} and change their internal state in response to each input event.
% In the terminology of FRP, each NFA-simulating deterministic CRN is literally a \emph{signal function} that, when given a valid input signal, produces an output signal that encodes each of the state transitions of the NFA while it processes its input.
Another example of using deterministic CRNs in this way is~\cite{rdc} which implements arbitrary combinational circuits that react in real time to their input signals and produce output signals in response according to traditional logic gates.
% Many biological systems found in nature behave in a similar fashion, where when presented with a pulse of a specific molecule type, will react in some way.
% \todo{Consider removing the previous sentence or finding relevant citations to back it up}
Both of these examples regard deterministic CRNs as \emph{signal functions} in functional reactive programming terms.

\todo{Titus needs to continue editing here...}

\subsection{\reactamole{}: A FRP Language for DCRNs}
\label{sub:dcrn_haskell_language}

We have begun to explore the design of a functional reactive programming language, \reactamole{}, that captures this approach to molecular programming for deterministic CRNs.
\reactamole is currently an embdded domain specific language in Haskell although we envision a full language design including a type system based on \emph{temporal linear logic} which is commonly used to verify properties of DCRNs.
We present our initial findings that help validate FRP as a promising approach to molecular programming and our plan for evolving these findings into a complete language.

\subsubsection{Introducing \reactamole{}}

The following key insight motives our design of \reactamole{}:
\begin{displayquote}
A chemical reaction network is a signal function in a functional reactive program over molecule concentrations.
\end{displayquote}
In our interpretation of molecular programming, molecules and their concentrations serve as \emph{signals} that encode values of various types.
For example, to represent a value of boolean type (\hask{Bool} in Haskell), we use two species in tandem in a \emph{dual-rail representation}~\todo{cite?}, designating one species as the ``hi'' wire and the other as the ``lo'' wire.
Pairs of values (of polymorphic Haskell type \hask{(a, b)}), in contrast, are simply two species that exist in the beaker together.
Because of the physical nature of a deterministic CRN---concentrations are high enough so that, effectively, every species ``sees'' every other species in the beaker---we do not need to impose additional structure to capture pairs!
Notably, \reactamole{} hides the choice of particular species from the user, generating fresh species names to ensure that a particular species is not used in a conflicting manner.

A CRN, then, becomes a time-varying function of molecules, a \emph{signal function}.
In \reactamole, we realize this with the type, \hask{DCRN a b}, the type of deterministic CRNs that take values of type \hask{a} as input and produce values of type \hask{b}.
Like other ``arrowized'', signal-based FRP implementations such as Yampa~\cite{dominguez:2018:thesis}, \reactamole{} does not provide support for manipulating molecules/signals directly.
Instead, it provides a set \emph{primitive signal functions} as well as \emph{combinator functions} that take CRNs/signal function as input and produce CRNs/signal functions as output.

To do this, \reactamole{} works exclusively with the \emph{I/O CRN} model of Ellis, Klinge, and Lathrop~\cite{rdc}.
In an I/O CRN, reactants act exclusively as catalysts, \ie, are not consumed in the reaction.
This means that the inputs to a CRN effectively as read-only values which allows \reactamole{}'s combinator to manipulate CRNs in a functional manner, avoiding thorny issues, such as race conditions between reactants.
\todo{Titus: can you add a few sentences here about the known restrictions of I/O CRNs and how essential our choice of the I/O CRN model here is?}

As an example, the NAND gate CRN described previously would have type:
\begin{haskellcode}
nand :: DCRN (Bool, Bool) Bool
\end{haskellcode}
This type describes, equivalently:
\begin{itemize}[itemsep=0pt]
  \item A signal function in functional reaction programming that takes pairs of booleans as input and a boolean as output.
  \item A deterministic chemical reaction network whose underlying reactants represent a pair of booleans and products represent a boolean.
\end{itemize}
\reactamole{} provides \hask{nand} as a primitive whose underlying implementation is the description of a robust \hask{nand} I/O CRN designed by Ellis, \etal~\cite{rdc}.

\hask{nand} is universal for boolean logic, so we can use this primitive to write other functions between booleans.
For example, we can define a DCRN that acts as a \emph{S-R latch} in \reactamole{} as follows:
\begin{haskellcode}
srlatch :: DCRN (Bool, Bool) Bool
srlatch = proc (sn, rn) -> do
    rec q  <- nand -< (sn, qn)
        qn <- nand -< (rn, q)
    returnA -< q
\end{haskellcode}
This code takes advantage of the \emph{arrows} combinators of Hughes~\cite{hughes:2000:arrows} that \reactamole{} implements and Haskell provides special syntax for via the \hask{Arrows} extension.
\hask{srlatch} is defined to be the composition of two \hask{nand}s set in a \emph{feedback loop}.
The arrow binding \hask{q <- nand -< (sn, qn)} sends the input \hask{(sn, qn)} to \hask{nand} and names the output \hask{q} for further computation.
A looping network of signals is defined with the \hask{rec} keyword which then allows the bindings to mutually refer to each other.
Finally, \hask{returnA -< q} returns \hask{q} from the function.

In our initial exploration, we have implemented all of the arrow combinators of Hughes as transformations over I/O CRNs.
For example, the \emph{split arrow} combinator has type:
\begin{haskellcode}
(***) :: DCRN a b -> DCRN a' b' -> DCRN (a, a') (a', b')
f *** g = return $ DCRN (reactions f ++ reactions g)
\end{haskellcode}
That is, the combinator comes two DCRNs by pairing their inputs and outputs together.
Because \reactamole{} maintains ``freshness'' of species names and we work with I/O CRNs whose reactants are catalytic, we obtain the behavior of split arrow by creating a new CRN generated from the \emph{union} of the two input CRNs.
We have also implemented the lifting function of arrows \hask{arr} but specialized to booleans.
This implementation utilizes \hask{nand} to take \emph{any} boolean function written in Haskell and translate it into an appropriate CRN.
For example, lifting a Haskell-based definition of \hask{&&}, the logical AND function, \hask{arr2 (&&)} yields a CRN whose underlying \reactamole{} implementation is given in~\autoref{fig:and-crn}.

\begin{figure}
\begin{center}
\begin{BVerbatim}
2x4 + ~x4 -[3.0e-2]-> 3x4
x4 + 2~x4 -[3.0e-2]-> 3~x4
x0 + x1 + x4 -[1.0e-2]-> x0 + x1 + ~x4
~x0 + ~x4 -[1.0e-2]-> ~x0 + x4
~x1 + ~x4 -[1.0e-2]-> ~x1 + x4
2x5 + ~x5 -[3.0e-2]-> 3x5
x5 + 2~x5 -[3.0e-2]-> 3~x5
x4 + x4 + x5 -[1.0e-2]-> x4 + x4 + ~x5
~x4 + ~x5 -[1.0e-2]-> ~x4 + x5
~x4 + ~x5 -[1.0e-2]-> ~x4 + x5
\end{BVerbatim}
\caption{The generated CRN from lifting logical AND, \hask{arr2 (&&)}.
  \hask{x0}, \hask{~x0}, \hask{x1}, \hask{~x1} are the dual-rail species of the inputs to \hask{(&&)}.
  \hask{x5} and \hask{~x5} are the dual-rail species of the output.}
\label{fig:and-crn}
\end{center}
\end{figure}

\subsection{From Prototype to Complete Language}

\begin{itemize}[itemsep=0pt]
  \item Shape of target language and missing features.
  \item Discussion of LTL-based type system.
\end{itemize}

\todo{I am just rambling at this point. How much detail do we want to go into in the implementation of all this?}

% 3. FRP and Deterministic CRNs
%     * Briefly introduce the input/output deterministic CRN model
%     * Draw connections between between the previous works on
%       chemical circuits and finite automata and FRP
%     * In particular, emphasize how these CRNs are literally signal
%       functions in the FRP sense that transform one type of signal
%       into another
%     * Drawing connections with how real biological systems use
%       molecular communication and react to input signals changing
%       such as the cell cycle switch
%     * Overview Ally's work on deterministic CRNs, the IOCRN type,
%       the Arrow implementations, and examples
%     * Show how the NAND gate and S-R latch can easily be implemented
%       in this characterization. Use the Yampa Arrow syntax to
%       demonstrate how the S-R latch can be implemented using
%       two NAND gates and the Arrow combinators
%     * Emphasize how the Bool type encapsulates the idea of a dual
%       rail encoding whereas the Double type is a continuous real
%       valued signal
%     * Discuss how STL (a continuous-space variant of LTL) is a natural
%       choice for a type system. Give examples of how the requirements
%       of the NAND gate and finite automata can be specified in STL


\subsection*{Titus Random Thoughts on NAND Requirements in STL}
\todo{These are experimental ideas that can be discarded if not needed}
In PI Klinge and PI Lathrop's paper on robust chemical circuits CITE, they formally define the requirements of a NAND gate.
Their definition can easily be written in \emph{signal temporal logic} (\emph{STL}) which is almost identical to LTL except that it tailored to systems with continuous state spaces.
The NAND gate has four input species \( X_1, \overline{X}_1, X_2, \overline{X}_2  \) and two output species \( Y, \overline{Y} \).
Intuitively, these three pairs of species represent the Boolean inputs and Boolean output of the NAND gate using the common \emph{dual rail} encoding of Booleans.
The requirement of the NAND gate can simply be written \( \Box(\phi_1 \land \phi_2) \) where \( \phi_1 \) and \( \phi_2 \) are two STL expressions that describe the two cases of the truth table of a NAND gate.
These expressions can be written:
\begin{align*}
    \phi_1 &= \Box_{[a,b]} (X_1 = 1 \land X_2 = 1) \rightarrow \Box_{[a+\tau, b]} (Y = 0)\\
    \phi_2 &= \Box_{[a,b]} (X_1 = 0 \lor X_2 = 0)  \rightarrow \Box_{[a+\tau, b]} (Y = 1)
\end{align*}
Intuitively, the combined STL statement \( \Box(\phi_1 \land \phi_2) \) says that whenever the input signal holds \( X_1 = 1 \) and \( X_2 = 1 \) during the interval \( [a,b] \), then the output signal must hold \( Y = 0 \) during the interval \( [a+\tau, b] \).
The constant \( \tau \) is commonly called the \emph{propagation delay} and describes how responsive a NAND gate is to its inputs changing.

In the previous example of the NAND gate requirement, we can consider the CRN implementing the NAND gate requirement as a \emph{signal function}.
Whenever the input signal contains an input event such as \( \Box_{[a,b](X_1 = 1 \land X_2 = 1)} \), then the output signal produces an output event \( \Box_{[a+\tau, b]}(Y = 0) \).
As a result, the signal function the CRN implements a ``lift'' of the pure function
\[
    f(x_1, x_2) =
    \begin{cases}
        0, &\text{ if }x_1 = x_2 = 1\\
        1, &\text{ otherwise}
    \end{cases}.
\]
Combining such CRNs with FRP combinators such as \hask{>>>}, \hask{&&&}, and \hask{***} combines these signal functions into new signal functions that can implement any finite combinational Boolean function.
The authors painstakingly proved that the composition of these signal functions transforms their input signals into the appropriate output signals.
However, this approach to molecular programming is exactly functional reactive programming.

We propose to place a type system on top of our embedded Haskell language that statically verifies STL statements of this form.
To our knowledge, such an approach has never been attempted, and could have broad impacts on both the correctness and safety of molecular programs and accelerate the development process.

\subsection*{Titus Random Thoughts on NFA Requirements in STL}
Similar to the previous section, PI Klinge and PI Lathrop were co-authors on a paper using deterministic CRNs to implement arbitrary nondeterministic finite automata (NFAs).
These CRNs had formal requirements that are also conducive to functional reactive programming.
In particular, the input signals provided to the an NFA-simulating CRN included a sequence of \emph{symbol events} which are intervals \( [a,b] \) that encode a symbol \( a\in\Sigma \) of the NFA's input alphabet.
The NFA-simulating CRN would process these symbols in real time, while updating its internal state to reflect the current states the NFA would be in after processing those symbols.
The output signal of this CRN also consisted of a sequence of intervals \( I_1, I_2, \ldots \) where each interval encoded a set of states \( A\subseteq Q \) of the NFA that are reachable from the starting states while processing each symbol of the input.

In this case, the NFA-simulating CRN is also a signal function that receives an input signal that contains a sequence of symbol events and produces an output signal consisting of state change events.
In particular, the CRN can be regarded as a \emph{casual function} that implements the transition function \( \delta(q,a) \) of the NFA.
