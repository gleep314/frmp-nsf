%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FRP and Deterministic CRNs}
\label{sec:frp_dcrns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Arguably the most prominent semantics for chemical reaction networks is \emph{deterministic mass action kinetics}, where the molecular counts of each species is modeled as a continuously-varying concentration.
Moreover, these species concentrations evolve continuously according to a system of ordinary differential equations.
Deterministic CRNs are inherently \emph{analog} and are closely related to Shannon's general purpose analog computer (GPAC) model (CITE).
\todo{CITE}
Commonly, deterministic CRNs and GPACs receive their input via an \emph{initial state} (at time zero), process it, and present their output at some future time \( t \)---or even converge to the appropriate output as \( t \) approaches infinity.
However, such machines can also be used as \emph{signal processors} that receive a continuously varying input signal and transform it in real time into a continuously varying output signal.
This characterization of computation with deterministic CRNs is used in CITE \todo{CITE} to show that any nondeterministic finite automaton can be simulated in real time by a deterministic CRN.
These CRNs receive their input strings as a sequence of \emph{pulses} and change its internal state in response to each input event.
Each NFA simulating deterministic CRN is literally a signal combinator that, when given a sequence of pulses, produces its own sequence of pulses that encodes the current state transitions of the NFA while processing the signal.
Many biological systems found in nature behave in a similar fashion, where when presented with a pulse of a specific molecule type, will react in some way.
\todo{Fix this paragraph}
Another example of using deterministic CRNs in this way is CITE \todo{CITE} which implements arbitrary combinational circuits that react in real time to their input signals and produce output signals in response according to traditional logic gates.

Both of these examples, the NFA-simulating CRNs and the circuit-simulating CRNs, are literally \emph{signal functions} in functional reactive programming terms.
We propose to develop a functional reactive language, embedded in Haskell, that captures this approach to molecular programming.
A deterministic CRN would then be typed with \hask{DCRN a b} that is comparable to Yampa's signal function \hask{SF a b} so that it receives a time varying signal \hask{Time -> a} and produces a new signal \hask{Time -> b}.
For example, the NAND gate CRN described above would have type:

\begin{haskellcode}
nand :: DCRN (Bool, Bool) Bool
\end{haskellcode}

This says that \hask{nand} is a deterministic CRN that receives an input signal that encodes two Boolean values at all times and produces a new signal that is the conjunction of these two signals at all times \( t \).
If the \hask{DCRN} type is an instance of Yampa's \hask{Arrow} and \hask{ArrowLoop} typeclasses, then it is possible to construct an S-R latch by combining two \hask{nand} CRNs together using the following syntax:

\begin{haskellcode}
srlatch :: DCRN (Bool, Bool) Bool
srlatch = proc (sn, rn) -> do
    rec q  <- ynand -< (sn, qn)
        qn <- ynand -< (rn, q)
    returnA -< q
\end{haskellcode}

The definition of \hask{DCRN} in our preliminary work is:
\begin{haskellcode}
data DCRN a b = DCRN { reactions :: [Reaction]
                     , inputs    :: Species a
                     , outputs   :: Species b  }
\end{haskellcode}
where \hask{reactions} is a list of \hask{Reaction}s that store the reactants, products, and rate constant of each reaction, and where \hask{Species} is a parameterized type defined by
\begin{haskellcode}
    data Species a where
        BoolSpecies   :: Name -> Name -> Species Bool
        DoubleSpecies :: Name -> Species Double
        PairSpecies   :: Species a -> Species b -> Species (a, b)
\end{haskellcode}

\todo{I am just rambling at this point. How much detail do we want to go into in the implementation of all this?}

% 3. FRP and Deterministic CRNs
%     * Briefly introduce the input/output deterministic CRN model
%     * Draw connections between between the previous works on
%       chemical circuits and finite automata and FRP
%     * In particular, emphasize how these CRNs are literally signal
%       functions in the FRP sense that transform one type of signal
%       into another
%     * Drawing connections with how real biological systems use
%       molecular communication and react to input signals changing
%       such as the cell cycle switch
%     * Overview Ally's work on deterministic CRNs, the IOCRN type,
%       the Arrow implementations, and examples
%     * Show how the NAND gate and S-R latch can easily be implemented
%       in this characterization. Use the Yampa Arrow syntax to
%       demonstrate how the S-R latch can be implemented using
%       two NAND gates and the Arrow combinators
%     * Emphasize how the Bool type encapsulates the idea of a dual
%       rail encoding whereas the Double type is a continuous real
%       valued signal
%     * Discuss how STL (a continuous-space variant of LTL) is a natural
%       choice for a type system. Give examples of how the requirements
%       of the NAND gate and finite automata can be specified in STL


\subsection*{Titus Random Thoughts on NAND Requirements in STL}
\todo{These are experimental ideas that can be discarded if not needed}
In PI Klinge and PI Lathrop's paper on robust chemical circuits CITE, they formally define the requirements of a NAND gate.
Their definition can easily be written in \emph{signal temporal logic} (\emph{STL}) which is almost identical to LTL except that it tailored to systems with continuous state spaces.
The NAND gate has four input species \( X_1, \overline{X}_1, X_2, \overline{X}_2  \) and two output species \( Y, \overline{Y} \).
Intuitively, these three pairs of species represent the Boolean inputs and Boolean output of the NAND gate using the common \emph{dual rail} encoding of Booleans.
The requirement of the NAND gate can simply be written \( \Box(\phi_1 \land \phi_2) \) where \( \phi_1 \) and \( \phi_2 \) are two STL expressions that describe the two cases of the truth table of a NAND gate.
These expressions can be written:
\begin{align*}
    \phi_1 &= \Box_{[a,b]} (X_1 = 1 \land X_2 = 1) \rightarrow \Box_{[a+\tau, b]} (Y = 0)\\
    \phi_2 &= \Box_{[a,b]} (X_1 = 0 \lor X_2 = 0)  \rightarrow \Box_{[a+\tau, b]} (Y = 1)
\end{align*}
Intuitively, the combined STL statement \( \Box(\phi_1 \land \phi_2) \) says that whenever the input signal holds \( X_1 = 1 \) and \( X_2 = 1 \) during the interval \( [a,b] \), then the output signal must hold \( Y = 0 \) during the interval \( [a+\tau, b] \).
The constant \( \tau \) is commonly called the \emph{propagation delay} and describes how responsive a NAND gate is to its inputs changing.

In the previous example of the NAND gate requirement, we can consider the CRN implementing the NAND gate requirement as a \emph{signal function}.
Whenever the input signal contains an input event such as \( \Box_{[a,b](X_1 = 1 \land X_2 = 1)} \), then the output signal produces an output event \( \Box_{[a+\tau, b]}(Y = 0) \).
As a result, the signal function the CRN implements a ``lift'' of the pure function
\[
    f(x_1, x_2) =
    \begin{cases}
        0, &\text{ if }x_1 = x_2 = 1\\
        1, &\text{ otherwise}
    \end{cases}.
\]
Combining such CRNs with FRP combinators such as \hask{>>>}, \hask{&&&}, and \hask{***} combines these signal functions into new signal functions that can implement any finite combinational Boolean function.
The authors painstakingly proved that the composition of these signal functions transforms their input signals into the appropriate output signals.
However, this approach to molecular programming is exactly functional reactive programming.

We propose to place a type system on top of our embedded Haskell language that statically verifies STL statements of this form.
To our knowledge, such an approach has never been attempted, and could have broad impacts on both the correctness and safety of molecular programs and accelerate the development process.

\subsection*{Titus Random Thoughts on NFA Requirements in STL}
Similar to the previous section, PI Klinge and PI Lathrop were co-authors on a paper using deterministic CRNs to implement arbitrary nondeterministic finite automata (NFAs).
These CRNs had formal requirements that are also conducive to functional reactive programming.
In particular, the input signals provided to the an NFA-simulating CRN included a sequence of \emph{symbol events} which are intervals \( [a,b] \) that encode a symbol \( a\in\Sigma \) of the NFA's input alphabet.
The NFA-simulating CRN would process these symbols in real time, while updating its internal state to reflect the current states the NFA would be in after processing those symbols.
The output signal of this CRN also consisted of a sequence of intervals \( I_1, I_2, \ldots \) where each interval encoded a set of states \( A\subseteq Q \) of the NFA that are reachable from the starting states while processing each symbol of the input.

In this case, the NFA-simulating CRN is also a signal function that receives an input signal that contains a sequence of symbol events and produces an output signal consisting of state change events.
In particular, the CRN can be regarded as a \emph{casual function} that implements the transition function \( \delta(q,a) \) of the NFA.
