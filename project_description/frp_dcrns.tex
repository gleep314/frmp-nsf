%!TEX root = project_description.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FRP and Deterministic CRNs}
\label{sec:frp_dcrns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One of the most prominent semantics for chemical reaction networks is \emph{deterministic mass action kinetics}, where the number of molecules of each species is modeled as a continuously-varying concentration~\cite{oErdTot89,oEpsPoj98,oGuna03,oLent15}.
These concentrations evolve according to a system of ordinary differential equations (ODEs), derived from the \emph{law of mass action} and the reactions within the network.
Deterministic CRNs are inherently \emph{analog} and are closely related to Shannon's general purpose analog computer (GPAC)~\cite{jShan41,jGraCos03,jGrac04,cBoGrPo16,cFLBP17,rtcrn2}.
For example, the CRN \( X_1 + X_2 \goesto{} Y \) from Figure~\ref{fig:min_max_example} (a) computes the \emph{minimum} of the initial concentrations of \( X_1 \) and \( X_2 \).
The law of mass action requires that the rate of this reaction at time \( t \) is proportional to the product of the concentration of its reactants at time \( t \), denoted by \( x_1(t) \) and \( x_2(t) \).
Since this reaction has a positive net effect on \( Y \) and a negative net effect on \( X_1 \) and \( X_2 \), the ODEs for the three species are:
\[
    \frac{dx_1}{dt} = -x_1(t)x_2(t), \qquad
    \frac{dx_2}{dt} = -x_1(t)x_2(t), \qquad
    \frac{dy}{dt}   =  x_1(t)x_2(t).
\]

Commonly, deterministic CRNs and GPACs receive their input via an \emph{initial state} (at time zero), process it, and present their output at some future time \( t \).
For the CRN computing the minimum function above, the concentration of its output \( Y \) converges to the appropriate value as \( t \) approaches infinity.
However, deterministic CRNs and GPACs can also be regarded as \emph{signal processors} that receive a continuously varying input signal, while producing a continuous output signal in real time.
This characterization of computation with deterministic CRNs is used in~\cite{jKlLaLu20} to show that any nondeterministic finite automaton can be simulated in real time by a deterministic CRN.
These CRNs receive their input strings as a sequence of \emph{pulses} and change their internal state in response to each input event.
% In the terminology of FRP, each NFA-simulating deterministic CRN is literally a \emph{signal function} that, when given a valid input signal, produces an output signal that encodes each of the state transitions of the NFA while it processes its input.
Another example of using deterministic CRNs in this way is~\cite{rdc} which implements arbitrary combinational circuits that react in real time to their input signals and produce output signals in response according to traditional logic gates.
% Many biological systems found in nature behave in a similar fashion, where when presented with a pulse of a specific molecule type, will react in some way.
% \todo{Consider removing the previous sentence or finding relevant citations to back it up}
Both of these examples regard deterministic CRNs as \emph{signal functions} in functional reactive programming terms.

\todo{Titus needs to continue editing here...}

\subsection{\reactamole{}: A FRP Language for DCRNs}
\label{sub:dcrn_haskell_language}

We have begun to explore the design of a functional reactive programming language, \reactamole{}, that captures this approach to molecular programming for deterministic CRNs.
\reactamole is currently an embdded domain specific language in Haskell although we envision a full language design including a type system based on \emph{temporal linear logic} which is commonly used to verify properties of DCRNs.
We present our initial findings that help validate FRP as a promising approach to molecular programming and our plan for evolving these findings into a complete language.

\subsubsection{Introducing \reactamole{}}

% 1. Choice of representations in Reactamole.
% 2. Examples of constructs in Reactamole.
% 3. Discussion of benefits gained so far.

The following key insight motives our design of \reactamole{}:
\begin{displayquote}
A chemical reaction network is a signal function in a functional reactive program over molecule concentrations.
\end{displayquote}
In our FRP interpretation of molecular programming, molecules and their concentrations serve as signals that encode values of various types.
A CRN, then, becomes a time-varying function of values, a \emph{signal function}.
In \reactamole, we realize this with the type, \hask{DCRN a b}, the type of deterministic CRNs that take values of type \hask{a} as input and produce values of type \hask{b}.
This is comparable to the signal function type found in many FRP libraries, \eg, \hask{SF a b} as defined in Yampa.
The various FRP combinators over signal function then take CRNs as input and produce CRNs as output.

For example, the NAND gate CRN described above would have type:
\begin{haskellcode}
nand :: DCRN (Bool, Bool) Bool
\end{haskellcode}

This says that \hask{nand} is a deterministic CRN that receives an input signal that encodes two Boolean values at all times and produces a new signal that is the conjunction of these two signals at all times \( t \).
If the \hask{DCRN} type is an instance of Yampa's \hask{Arrow} and \hask{ArrowLoop} typeclasses, then it is possible to construct an S-R latch by combining two \hask{nand} CRNs together using the following syntax:

\begin{haskellcode}
srlatch :: DCRN (Bool, Bool) Bool
srlatch = proc (sn, rn) -> do
    rec q  <- ynand -< (sn, qn)
        qn <- ynand -< (rn, q)
    returnA -< q
\end{haskellcode}

The definition of \hask{DCRN} in our preliminary work is:
\begin{haskellcode}
data DCRN a b = DCRN { reactions :: [Reaction]
                     , inputs    :: Species a
                     , outputs   :: Species b  }
\end{haskellcode}
where \hask{reactions} is a list of \hask{Reaction}s that store the reactants, products, and rate constant of each reaction, and where \hask{Species} is a parameterized type defined by
\begin{haskellcode}
data Species a where
    BoolSpecies   :: Name -> Name -> Species Bool
    DoubleSpecies :: Name -> Species Double
    PairSpecies   :: Species a -> Species b -> Species (a, b)
\end{haskellcode}

\subsection{From Prototype to Compelete Language}

\begin{itemize}[itemsep=0pt]
  \item Shape of target language and missing features.
  \item Discussion of LTL-based type system.
\end{itemize}

\todo{I am just rambling at this point. How much detail do we want to go into in the implementation of all this?}

% 3. FRP and Deterministic CRNs
%     * Briefly introduce the input/output deterministic CRN model
%     * Draw connections between between the previous works on
%       chemical circuits and finite automata and FRP
%     * In particular, emphasize how these CRNs are literally signal
%       functions in the FRP sense that transform one type of signal
%       into another
%     * Drawing connections with how real biological systems use
%       molecular communication and react to input signals changing
%       such as the cell cycle switch
%     * Overview Ally's work on deterministic CRNs, the IOCRN type,
%       the Arrow implementations, and examples
%     * Show how the NAND gate and S-R latch can easily be implemented
%       in this characterization. Use the Yampa Arrow syntax to
%       demonstrate how the S-R latch can be implemented using
%       two NAND gates and the Arrow combinators
%     * Emphasize how the Bool type encapsulates the idea of a dual
%       rail encoding whereas the Double type is a continuous real
%       valued signal
%     * Discuss how STL (a continuous-space variant of LTL) is a natural
%       choice for a type system. Give examples of how the requirements
%       of the NAND gate and finite automata can be specified in STL


\subsection*{Titus Random Thoughts on NAND Requirements in STL}
\todo{These are experimental ideas that can be discarded if not needed}
In PI Klinge and PI Lathrop's paper on robust chemical circuits CITE, they formally define the requirements of a NAND gate.
Their definition can easily be written in \emph{signal temporal logic} (\emph{STL}) which is almost identical to LTL except that it tailored to systems with continuous state spaces.
The NAND gate has four input species \( X_1, \overline{X}_1, X_2, \overline{X}_2  \) and two output species \( Y, \overline{Y} \).
Intuitively, these three pairs of species represent the Boolean inputs and Boolean output of the NAND gate using the common \emph{dual rail} encoding of Booleans.
The requirement of the NAND gate can simply be written \( \Box(\phi_1 \land \phi_2) \) where \( \phi_1 \) and \( \phi_2 \) are two STL expressions that describe the two cases of the truth table of a NAND gate.
These expressions can be written:
\begin{align*}
    \phi_1 &= \Box_{[a,b]} (X_1 = 1 \land X_2 = 1) \rightarrow \Box_{[a+\tau, b]} (Y = 0)\\
    \phi_2 &= \Box_{[a,b]} (X_1 = 0 \lor X_2 = 0)  \rightarrow \Box_{[a+\tau, b]} (Y = 1)
\end{align*}
Intuitively, the combined STL statement \( \Box(\phi_1 \land \phi_2) \) says that whenever the input signal holds \( X_1 = 1 \) and \( X_2 = 1 \) during the interval \( [a,b] \), then the output signal must hold \( Y = 0 \) during the interval \( [a+\tau, b] \).
The constant \( \tau \) is commonly called the \emph{propagation delay} and describes how responsive a NAND gate is to its inputs changing.

In the previous example of the NAND gate requirement, we can consider the CRN implementing the NAND gate requirement as a \emph{signal function}.
Whenever the input signal contains an input event such as \( \Box_{[a,b](X_1 = 1 \land X_2 = 1)} \), then the output signal produces an output event \( \Box_{[a+\tau, b]}(Y = 0) \).
As a result, the signal function the CRN implements a ``lift'' of the pure function
\[
    f(x_1, x_2) =
    \begin{cases}
        0, &\text{ if }x_1 = x_2 = 1\\
        1, &\text{ otherwise}
    \end{cases}.
\]
Combining such CRNs with FRP combinators such as \hask{>>>}, \hask{&&&}, and \hask{***} combines these signal functions into new signal functions that can implement any finite combinational Boolean function.
The authors painstakingly proved that the composition of these signal functions transforms their input signals into the appropriate output signals.
However, this approach to molecular programming is exactly functional reactive programming.

We propose to place a type system on top of our embedded Haskell language that statically verifies STL statements of this form.
To our knowledge, such an approach has never been attempted, and could have broad impacts on both the correctness and safety of molecular programs and accelerate the development process.

\subsection*{Titus Random Thoughts on NFA Requirements in STL}
Similar to the previous section, PI Klinge and PI Lathrop were co-authors on a paper using deterministic CRNs to implement arbitrary nondeterministic finite automata (NFAs).
These CRNs had formal requirements that are also conducive to functional reactive programming.
In particular, the input signals provided to the an NFA-simulating CRN included a sequence of \emph{symbol events} which are intervals \( [a,b] \) that encode a symbol \( a\in\Sigma \) of the NFA's input alphabet.
The NFA-simulating CRN would process these symbols in real time, while updating its internal state to reflect the current states the NFA would be in after processing those symbols.
The output signal of this CRN also consisted of a sequence of intervals \( I_1, I_2, \ldots \) where each interval encoded a set of states \( A\subseteq Q \) of the NFA that are reachable from the starting states while processing each symbol of the input.

In this case, the NFA-simulating CRN is also a signal function that receives an input signal that contains a sequence of symbol events and produces an output signal consisting of state change events.
In particular, the CRN can be regarded as a \emph{casual function} that implements the transition function \( \delta(q,a) \) of the NFA.
